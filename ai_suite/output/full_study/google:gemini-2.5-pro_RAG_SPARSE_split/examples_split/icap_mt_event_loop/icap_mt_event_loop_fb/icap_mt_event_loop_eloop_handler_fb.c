// Example from Kasper Svendsen and Lars Birkedal, Impredicative Concurrent Abstract Predicates, ESOP 2014.

#include <stdlib.h>
#include "gotsmanlock.h"


typedef struct eloop *eloop;

// Forward declaration of the function pointer type is needed for the struct definition.
typedef void eloop_handler(void *data);

struct eloop {
    int lock;
    int signalCount;
    eloop_handler *handler;
    //@ predicate(void *) dataPred;
    void *handlerData;
};

/*@

// NOTE: The provided 'gotsmanlock.h' specification is non-standard and problematic.
// For verification purposes, we assume a standard non-reentrant lock specification.
predicate lock(int* l, predicate() I); 
predicate locked(int* l, predicate() I);  

lemma void acquire(int* l);
    requires lock(l, ?I);
    ensures locked(l, I) &*& I();

lemma void release(int* l);
    requires locked(l, ?I) &*& I();
    ensures lock(l, I);

predicate_ctor I(eloop x)() =
    x->signalCount |-> ?signalCount &*& 0 <= signalCount &*&
    x->handler |-> ?h &*&
    x->dataPred |-> ?dataPred &*&
    h == 0 ?
        x->handlerData |-> _ &*&
        true
    :
        x->handlerData |-> ?data &*&
        // The is_eloop_handler predicate is generated by VeriFast for the eloop_handler function type.
        // It asserts that 'h' is a function pointer that satisfies the contract of eloop_handler
        // with the given ghost parameters.
        [_]is_eloop_handler(h, x, dataPred) &*& [_]dataPred(data);

// The eloop predicate represents full ownership of the lock, which is required to acquire it.
// The original fractional permission is changed to full permission to match the non-fractional lock model.
predicate eloop(eloop x) =
    lock(&x->lock, I(x));
@*/


// The contract for eloop_handler is corrected to reflect that it is called
// from within the critical section, i.e., when the lock is held.
// It requires the 'locked' predicate and the lock invariant 'I(x)()', and must preserve them.
typedef void eloop_handler/*@(eloop x, predicate(void *) dataPred)@*/(void *data);
    //@ requires locked(&x->lock, I(x)) &*& I(x)();
    //@ ensures locked(&x->lock, I(x)) &*& I(x)();

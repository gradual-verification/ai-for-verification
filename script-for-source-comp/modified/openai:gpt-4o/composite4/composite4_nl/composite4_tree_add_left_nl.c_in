struct node {
struct node *left;
struct node *right;
struct node *parent;
int count;
};
struct node * create_node(struct node * p)
{
struct node *n = malloc(sizeof(struct node));
if (n == 0) { abort(); }
n->left = 0;
n->right = 0;
n->parent = p;
n->count = 1;
return n;
}
int subtree_get_count(struct node *node)
{
int result = 0;
if (node != 0) { result = node->count; }
return result;
}
void fixup_ancestors(struct node * n, struct node * p, int count)
{
if (p == 0) {
} else {
struct node *left = p->left;
struct node *right = p->right;
struct node *grandparent = p->parent;
int leftCount = 0;
int rightCount = 0;
if (n == left) {
leftCount = count;
rightCount = subtree_get_count(right);
} else {
leftCount = subtree_get_count(left);
rightCount = count;
}
if (INT_MAX - 1 - leftCount < rightCount) {
abort();
}
{
int pcount = 1 + leftCount + rightCount;
p->count = pcount;
fixup_ancestors(p, grandparent, pcount);
}
}
}
struct node *tree_add_left(struct node *node)
{
struct node *n = create_node(node);
{
struct node *nodeLeft = node->left;
node->left = n;
fixup_ancestors(n, node, 1);
}
return n;
}
struct node {
struct node *left;
struct node *right;
struct node *parent;
int count;
};
struct node *create_tree()
{
struct node *n = malloc(sizeof(struct node));
if (n == 0) {
abort();
}
n->left = 0;
n->right = 0;
n->parent = 0;
n->count = 1;
return n;
}
int subtree_get_count(struct node *node)
{
int result = 0;
if (node == 0) {
} else {
result = node->count;
}
return result;
}
void fixup_ancestors(struct node *node, struct node *parent, int count)
{
if (parent == 0) {
} else {
struct node *left = parent->left;
struct node *right = parent->right;
struct node *grandparent = parent->parent;
int leftCount = 0;
int rightCount = 0;
if (node == left && node != right) {
leftCount = count;
rightCount = subtree_get_count(right);
} else if (node == right && node != left) {
leftCount = subtree_get_count(left);
rightCount = count;
} else {
abort();
}
if (rightCount < 0 || leftCount > INT_MAX - 1 - rightCount) { abort(); }
int parentCount = 1 + leftCount + rightCount;
parent->count = parentCount;
fixup_ancestors(parent, grandparent, parentCount);
}
}
struct node *tree_add_left(struct node *node)
{
if (node == 0) {
abort();
}
{
struct node *n = malloc(sizeof(struct node));
if (n == 0) {
abort();
}
n->left = 0;
n->right = 0;
n->parent = node;
n->count = 1;
{
struct node *nodeLeft = node->left;
if (nodeLeft != 0) {
abort();
}
node->left = n;
if (n == node->right) {
abort();
}
fixup_ancestors(n, node, 1);
}
return n;
}
}
struct node *tree_add_right(struct node *node)
{
if (node == 0) {
abort();
}
{
struct node *n = malloc(sizeof(struct node));
if (n == 0) {
abort();
}
n->left = 0;
n->right = 0;
n->parent = node;
n->count = 1;
{
struct node *nodeRight = node->right;
if (nodeRight != 0) {
abort();
}
node->right = n;
if (n == node->left) {
abort();
}
fixup_ancestors(n, node, 1);
}
return n;
}
}
struct node *tree_get_parent(struct node *node)
{
if (node == 0) {
abort();
}
{
struct node *parent = node->parent;
if (parent == 0) {
abort();
}
return parent;
}
}
void dispose_node(struct node *node)
{
if (node == 0) {
} else {
{
struct node *left = node->left;
dispose_node(left);
}
{
struct node *right = node->right;
dispose_node(right);
}
free(node);
}
}
void tree_dispose(struct node *node)
{
if (node == 0) {
abort();
}
{
struct node *parent = node->parent;
if (parent != 0) {
abort();
}
}
dispose_node(node);
}
int main()
{
struct node *node = create_tree();
node = tree_add_left(node);
node = tree_add_right(node);
node = tree_get_parent(node);
node = tree_add_left(node);
node = tree_get_parent(node);
node = tree_get_parent(node);
tree_dispose(node);
return 0;
}